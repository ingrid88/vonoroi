
<canvas id="c" width="500px" height="500px"></canvas>
<script>
var e = document.getElementById('c')
var g = e.getContext("2d")
// g.getImageData(mouseX, mouseY, 1, 1).data

WIDTH=500
HEIGHT=500
SEED_COUNT = 30

// Perform Build
SEEDS = add_seeds(SEED_COUNT)

var distance_measure = location.search.split('metric=')[1]

seeds = SEEDS
pixels = add_pixels(width=WIDTH, height=HEIGHT)
var pixel_matrix = paint_voronoi(seeds, pixels);
console.log(pixel_matrix);
paint_seeds(SEEDS, 3);
// RESEEDS = add_seeds(SEED_COUNT*10);
// // 1. get reseeds colors
// reseed_colors = []
//
//
// for(var i=0; i < RESEEDS.length; i++) {
//   // pixel_color = g.getImageData(p_x,p_y,1,1).data
//   x = RESEEDS[i][0]
//   y = RESEEDS[i][1]
//   seed_index = assign_pixel([x,y], SEEDS, distance_measure)
//   h = 360*seed_index/SEED_COUNT
//   reseed_colors.push([h,x,y])
// }
//
//
//
//
// console.log('reseed colors listed with x and y');
// console.log(reseed_colors)
// paint_seeds(RESEEDS, 1)
// pixel_color = g.getImageData(p_x,p_y,1,1).data
// 2. for all pixel_matrix with that color perform operation

// 3. perform for each color
// 4. recolor pixels (how?)

function add_pixels(width, height) {
  i = 0
  pixels = []
  for(var x=0; x < WIDTH; x++) {
    for(var y=0; y < HEIGHT; y++) {
      pixels[i] = [x,y]
      i += 1
    }
  }
  return pixels
}


function getCursorPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    var x = event.clientX - rect.left;
    var y = event.clientY - rect.top;
    console.log("x: " + x + " y: " + y);
    return [x,y]
}

// draw voronoi inside voronoi
document.getElementById("c").addEventListener("click", function(event){
  // get pos of mouse click
  mouse_click_position = getCursorPosition(e, event)
  var index = assign_pixel(mouse_click_position, SEEDS, euclidean_distance)
  // get pixels in that region
  var relevant_pixels = pixel_matrix.filter(value => index == value[2]);
  console.log(relevant_pixels.length);
  // Generate set of new_seeds in region
  var new_seeds = relevant_pixels.filter(value => Math.random() < .002)
  console.log(new_seeds);
  // Redraw voronoi segments
  paint_voronoi(new_seeds, relevant_pixels)
});



// document.getElementById("c").addEventListener("click", function(event){
//
//   // 1 get pos and closest seed
//   mouse_click_position = getCursorPosition(e, event)
//   var index = assign_pixel(mouse_click_position, SEEDS, euclidean_distance)
//   if (euclidean_distance(SEEDS[index][0], SEEDS[index][1], mouse_click_position[0], mouse_click_position[1]) > 10) {
//     //1a. Append position to SEEDS and increment SEED_COUNT
//     SEEDS.splice(index, 0, mouse_click_position)
//   } else {
//     // 1b. delete the seed
//     SEEDS.splice(index, 1)
//   }
//   // SEEDS.push(getCursorPosition(e, event))
//   //2. Rerun paint_vonoroi()
//   paint_voronoi()
//   //3. rerun paint_seeds()
//   paint_seeds(SEEDS,3)
// });



console.log(pixel_matrix)

function add_seeds(seed_count){
  var seeds = []
  for(var x=0; x < seed_count; x++) {
    for(var y=0; y < seed_count; y++) {
      u = Math.floor(Math.random()*WIDTH)
      v = Math.floor(Math.random()*HEIGHT)
      seeds[x] = [u,v]
    }
  }
  return seeds
}

function paint_voronoi(seeds, pixels, pixel_matrix=[]){
  for(var i=0; i< pixels.length; i++) {
    x = pixels[i][0]
    y = pixels[i][1]
    seed_index = assign_pixel([x,y], seeds, distance_measure)
    g.fillStyle = "hsl("+(360*seed_index/seeds.length)+",60%,60%)"
    g.fillRect(x,y,1,1)
    pixel_matrix[i] = [x,y,seed_index]
  }
  return pixel_matrix
}

function paint_seeds(seeds, size){
  seeds.forEach(function(seed){
    g.fillStyle = "black"
    g.fillRect(seed[0]-Math.floor(size/2),seed[1]-Math.floor(size/2),size,size)
  })
}

function assign_pixel(pixel, seeds, metric) {
  p_x = pixel[0]
  p_y = pixel[1]
  d = 500
  ind = 0
  for(var x=0; x < seeds.length; x++) {
    s_x = seeds[x][0]
    s_y = seeds[x][1]
    metric = euclidean_distance
    n_d = metric(s_x,s_y,p_x,p_y)
    d = (d < n_d) ? d : n_d
    ind = (d < n_d) ? ind : x
  }
  return ind
}


function l0_space(x,y,u,v) {
    return  Math.max(Math.abs(u-x), Math.abs(v-y))
}

function manhattan_distance(x,y,u,v) {
    return  Math.abs(u-x) + Math.abs(v-y)
}

function euclidean_distance(x,y,u,v) {
     return Math.sqrt(Math.pow((u-x),2) + Math.pow((v-y),2))
}

</script>
